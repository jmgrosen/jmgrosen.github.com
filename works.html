<!DOCTYPE html>

<html><head><meta charset="utf-8" />
<title>Works | Jessie Grosen</title>
<link rel="stylesheet" href="static/styles.css" />
<link rel="stylesheet" href="static/fa.min.css" /></head>
<body><header><h1>All Works</h1>
(sorted by date)</header>
<main><ul class="works"><li id="mustardwatch2022"><p class="work-type">(Seminar Talk)</p><p class="work-title">Three Decades of Mustard Watches: Theory, Practice, and Frontiers</p><p class="work-authors">J. Grosen</p><p class="work-venue">CMU PLunch</p><p class="work-links">[<a href="assets/talks/mustard-watches.pdf">slides+notes</a>] </p></li><li id="nestedaara2022"><p class="work-type">(Draft)</p><p class="work-title">Semantically Sound Resource Analysis with Nested Recursive Types</p><p class="work-authors">J. Grosen, D. Kahn, J. Hoffmann</p><p class="work-venue">March 2022</p><p class="work-links">[<a href="assets/papers/aara-nested-recursive.pdf">preprint</a>] </p><p class="work-abstract">The goal of automatic resource bound analysis is to statically infer symbolic bounds on the resource consumption of the evaluation of a program. Two longstanding challenges for automatic resource analysis are the inference of bounds that are functions of complex custom data structures and smooth integration with manual bound analysis. This article builds on type-based automatic amortized resource analysis (AARA) to address these two challenges. AARA is based on the potential method of amortized analysis and reduces bound inference to standard type inference with additional linear constraint solving, even when deriving non-linear bounds. A key component of AARA are resource functions that generate the space of possible bounds for values of a given type while enjoying necessary closure properties.</p><p class="work-abstract">Existing work on AARA defined such functions for many data structures such as lists of lists but the question of whether such functions exist for arbitrary data structures remained open. This work answers this questions positively by uniformly constructing resource polynomials for general algebraic data structures defined by possibly-nested recursive types. These functions are a generalization of all previously proposed polynomial resource functions and can be seen as a general notion of polynomials for values of a given recursive type. A resource type system for FPC, a core language with recursive types, demonstrates how resource polynomials can be integrated with AARA while preserving all benefits of the techniques.</p><p class="work-abstract">Existing work on AARA defined such functions for many data structures such as lists of lists but the question of whether such functions exist for arbitrary data structures remained open. This work answers this questions positively by uniformly constructing resource polynomials for general algebraic data structures defined by possibly-nested recursive types. These functions are a generalization of all previously proposed polynomial resource functions and can be seen as a general notion of polynomials for values of a given recursive type. A resource type system for FPC, a core language with recursive types, demonstrates how resource polynomials can be integrated with AARA while preserving all benefits of the techniques.</p></li><li id="mechanicalphish2018"><p class="work-type">(Other Publication)</p><p class="work-title">Mechanical Phish: Resilient Autonomous Hacking</p><p class="work-authors">Y. Shoshitaishvili, A. Bianchi, K. Borgolte, A. Cama, J. Corbetta, F. Disperati, A. Dutcher, J. Grosen, P. Grosen, A. Machiry, C. Salls, N. Stephens, R. Wang, G. Vigna</p><p class="work-venue">IEEE Security and Privacy (S&amp;P), March/April 2018 issue</p><p class="work-links"></p></li><li id="ramblr2017"><p class="work-type">(Refereed Publication)</p><p class="work-title">Ramblr: Making Reassembly Great Again</p><p class="work-authors">R. Wang, Y. Shoshitaishvili, A. Bianchi, A. Machiry, J. Grosen, P. Grosen, C. Kruegel, G. Vigna</p><p class="work-venue">Network and Distributed System Security Symposium (NDSS) 2017</p><p class="work-links">[<a href="http://dx.doi.org/10.14722/ndss.2017.23225">doi</a>] </p><p class="work-abstract">Static binary rewriting has many important applications in reverse engineering, such as patching, code reuse, and instrumentation. Binary reassembling is an efficient solution for static binary rewriting. While there has been a proposed solution to the reassembly of binaries, an evaluation on a realworld binary dataset shows that it suffers from some problems that lead to breaking binaries. Those problems include incorrect symbolization of immediates, failure in identifying symbolizable constants, lack of pointer safety checks, and other issues. Failure in addressing those problems makes the existing approach unsuitable for real-world binaries, especially those compiled with optimizations enabled.</p><p class="work-abstract">In this paper, we present a new systematic approach for binary reassembling. Our new approach is implemented in a tool called Ramblr. We evaluate Ramblr on 106 real-world programs on Linux x86 and x86-64, and 143 programs collected from the Cyber Grand Challenge Qualification Event. All programs are compiled to binaries with a set of different compilation flags in order to cover as many real-world scenarios as possible. Ramblr successfully reassembles most of the binaries, which is an improvement over the state-of-the-art approach. It should be noted that our reassembling procedure yields no execution overhead and no size expansion.</p></li><li id="angr2016"><p class="work-type">(Refereed Publication)</p><p class="work-title">(State of) The Art of War: Offensive Techniques in Binary Analysis</p><p class="work-authors">Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, G. Vigna</p><p class="work-venue">IEEE Symposium on Security and Privacy (Oakland) 2016</p><p class="work-links">[<a href="https://doi.org/10.1109/SP.2016.17">doi</a>] </p><p class="work-abstract">Finding and exploiting vulnerabilities in binary code is a challenging task. The lack of high-level, semantically rich information about data structures and control constructs makes the analysis of program properties harder to scale. However, the importance of binary analysis is on the rise. In many situations binary analysis is the only possible way to prove (or disprove) properties about the code that is actually executed. In this paper, we present a binary analysis framework that implements a number of analysis techniques that have been proposed in the past. We present a systematized implementation of these techniques, which allows other researchers to compose them and develop new approaches. In addition, the implementation of these techniques in a unifying framework allows for the direct comparison of these apporaches and the identification of their advantages and disadvantages. The evaluation included in this paper is performed using a recent dataset created by DARPA for evaluating the effectiveness of binary vulnerability analysis techniques. Our framework has been open-sourced and is available to the security community.</p></li><li id="driller2016"><p class="work-type">(Refereed Publication)</p><p class="work-title">Driller: Augmenting Fuzzing Through Selective Symbolic Execution</p><p class="work-authors">N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, G. Vigna</p><p class="work-venue">Network and Distributed System Security Symposium (NDSS) 2016</p><p class="work-links">[<a href="https://dx.doi.org/10.14722/ndss.2016.23368">doi</a>] [<a href="assets/papers/driller.pdf">pdf</a>] </p><p class="work-abstract">Memory corruption vulnerabilities are an everpresent risk in software, which attackers can exploit to obtain unauthorized access to confidential information. As products with access to sensitive data are becoming more prevalent, the number of potentially exploitable systems is also increasing, resulting in a greater need for automated software vetting tools. DARPA recently funded a competition, with millions of dollars in prize money, to further research focusing on automated vulnerability finding and patching, showing the importance of research in this area. Current techniques for finding potential bugs include static, dynamic, and concolic analysis systems, which each having their own advantages and disadvantages. A common limitation of systems designed to create inputs which trigger vulnerabilities is that they only find shallow bugs and struggle to exercise deeper paths in executables.</p><p class="work-abstract">We present Driller, a hybrid vulnerability excavation tool which leverages fuzzing and selective concolic execution in a complementary manner, to find deeper bugs. Inexpensive fuzzing is used to exercise compartments of an application, while concolic execution is used to generate inputs which satisfy the complex checks separating the compartments. By combining the strengths of the two techniques, we mitigate their weaknesses, avoiding the path explosion inherent in concolic analysis and the incompleteness of fuzzing. Driller uses selective concolic execution to explore only the paths deemed interesting by the fuzzer and to generate inputs for conditions that the fuzzer cannot satisfy. We evaluate Driller on 126 applications released in the qualifying event of event of the DARPA Cyber Grand Challenge and show its efficacy by identifying the same number of vulnerabilities, in the same time, as the top-scoring team of the qualifying event.</p></li></ul></main>
<footer>Last updated on 10 March 2022.</footer></body></html>