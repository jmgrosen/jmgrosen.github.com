{"index":{"title":"it's me","links":[],"tags":[],"content":"hey there\n"},"posts/distance-audio-modulator":{"title":"distance audio modulator","links":[],"tags":[],"content":"recently, my friend zero told me an idea it had to add some crowd-mediated interactivity to a live show: measure how close together a particular few people are by looking at bluetooth signal strengths, then report that back to the synth to modulate some parameters.\nwe whittled that down to a simpler starting place: estimate distances to a few devices directly from the central laptop, then emit some midi CC values based on that. with some trial and error, we got that to work! here’s a little demo video:\n\nit’s pretty inconsistent and high latency, as you can tell. i bet if we wrote a little app that sent out bluetooth pings every 25ms we could probably address those, though of course with some tradeoff between the two.\nhere’s the python script we wrote:\nimport asyncio\nimport hashlib\n \nimport ipdb\nfrom bleak import BleakScanner\nimport mido\n \n \nNUM_CCS = 8\nBASE_CC = 70\n \nMIN_RSSI = 0x30\nMAX_RSSI = 0x60\n \ndef clamp(lo, hi, x):\n    if x &lt; lo:\n        return lo\n    elif x &gt; hi:\n        return hi\n    else:\n        return x\n \ndef scale(from_lo, from_hi, to_lo, to_hi, x):\n    return (clamp(from_lo, from_hi, x) - from_lo) / (from_hi - from_lo) * (to_hi - to_lo) + to_lo\n \ndef rssi_to_midi(rssi):\n    return round(scale(MIN_RSSI, MAX_RSSI, 0, 127, abs(rssi)))\n \ndef valid_ad(dev, ad):\n    return dev.name is not None and \\\n           dev.name.startswith(&#039;Jessie&#039;) and \\\n           ad.rssi is not None and \\\n           (ad.tx_power is None or ad.tx_power &lt; 50)\n \ndef update_cc(port, cc, val):\n    port.send(mido.Message(&#039;control_change&#039;, control=cc, value=val))\n \nasync def main():\n    port = mido.open_output()\n    cc_nums = {}\n    async with BleakScanner() as scanner:\n        async for bd, ad in scanner.advertisement_data():\n            if not valid_ad(bd, ad):\n                continue\n            if bd.address not in cc_nums:\n                if len(cc_nums) &lt; NUM_CCS:\n                    cc_nums[bd.address] = BASE_CC + len(cc_nums)\n                else:\n                    continue\n \n            val = rssi_to_midi(ad.rssi - (ad.tx_power or 8))\n            print(f&quot;{bd.name} -&gt; {val}&quot;)\n            update_cc(port, cc_nums[bd.address], val)\n \n \nif __name__ == &#039;__main__&#039;:\n    asyncio.run(main())\nif i/we work on it any more, i’ll put it in a repo somewhere"}}