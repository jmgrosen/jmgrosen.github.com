{"index":{"title":"it's me","links":[],"tags":[],"content":"hey there!\n"},"interests/transit/nyc/R211T":{"title":"R211T","links":[],"tags":[],"content":"i managed to catch a ride on one of the MTA’s fancy new trains with open gangways!\n\n\nthey were quite snazzy and functional—i saw many people standing in the gangway while it was more crowded and rode just fine in it myself.\nbesides the open gangways, the most useful improvement i saw was the intricate wayfinding information displayed at each stop: where to find which staircases/elevators relative to one’s position. this convinced me that replacing the LED textual stop information with general purpose screens really is worth it.\n\ni saw these odd devices next to two of the doors (one on each side) on each car:\n\ni really could not figure out what their purpose is, even after searching online. if you have any idea, please let me know!\nhopefully they figure out a way to inspect between the cars so that it can run on the A as well."},"posts/distance-audio-modulator":{"title":"distance audio modulator","links":[],"tags":[],"content":"recently, my friend zero told me an idea it had to add some crowd-mediated interactivity to a live show: measure how close together a particular few people are by looking at bluetooth signal strengths, then report that back to the synth to modulate some parameters.\nwe whittled that down to a simpler starting place: estimate distances to a few devices directly from the central laptop, then emit some midi CC values based on that. with some trial and error, we got that to work! here’s a little demo video:\n\nit’s pretty inconsistent and high latency, as you can tell. i bet if we wrote a little app that sent out bluetooth pings every 25ms we could probably address those, though of course with some tradeoff between the two.\nhere’s the python script we wrote:\nimport asyncio\nimport hashlib\n \nimport ipdb\nfrom bleak import BleakScanner\nimport mido\n \n \nNUM_CCS = 8\nBASE_CC = 70\n \nMIN_RSSI = 0x30\nMAX_RSSI = 0x60\n \ndef clamp(lo, hi, x):\n    if x &lt; lo:\n        return lo\n    elif x &gt; hi:\n        return hi\n    else:\n        return x\n \ndef scale(from_lo, from_hi, to_lo, to_hi, x):\n    return (clamp(from_lo, from_hi, x) - from_lo) / (from_hi - from_lo) * (to_hi - to_lo) + to_lo\n \ndef rssi_to_midi(rssi):\n    return round(scale(MIN_RSSI, MAX_RSSI, 0, 127, abs(rssi)))\n \ndef valid_ad(dev, ad):\n    return dev.name is not None and \\\n           dev.name.startswith(&#039;Jessie&#039;) and \\\n           ad.rssi is not None and \\\n           (ad.tx_power is None or ad.tx_power &lt; 50)\n \ndef update_cc(port, cc, val):\n    port.send(mido.Message(&#039;control_change&#039;, control=cc, value=val))\n \nasync def main():\n    port = mido.open_output()\n    cc_nums = {}\n    async with BleakScanner() as scanner:\n        async for bd, ad in scanner.advertisement_data():\n            if not valid_ad(bd, ad):\n                continue\n            if bd.address not in cc_nums:\n                if len(cc_nums) &lt; NUM_CCS:\n                    cc_nums[bd.address] = BASE_CC + len(cc_nums)\n                else:\n                    continue\n \n            val = rssi_to_midi(ad.rssi - (ad.tx_power or 8))\n            print(f&quot;{bd.name} -&gt; {val}&quot;)\n            update_cc(port, cc_nums[bd.address], val)\n \n \nif __name__ == &#039;__main__&#039;:\n    asyncio.run(main())\nif i/we work on it any more, i’ll put it in a repo somewhere"},"projects/miscellanea/Zoom-G1Xon-control":{"title":"Zoom G1Xon control","links":[],"tags":[],"content":"these are notes from a project zero and i did to control the Zoom G1Xon guitar multi-effects pedal in real-time over USB.\nthere are various pieces of software to edit and store patches for Zoom pedals, but they’re not so great for real-time control. nonetheless, they contain lots of useful information. we got most of ours from this wonderful project page and some of the code linked from the home page of that wiki. the B1on is moooooostly the same as the G1Xon.\nthe pedal communicates with a USB host using MIDI SysEx and CC messages. as documented on that wiki page, most of the SysEx commands require a model ID specific to the pedal; while the B1on’s is 0x65, the G1Xon’s is 0x64. (you can find this out with the “Identify” command.) oddly, we found that some commands work with the incorrect model ID in the command, while others do not, so if you are having trouble with inconsistency, make sure you’re using the right model ID everywhere.\nwhen trying to receive data back from the pedal (whether for the Identify command, the Get(Current)Patch commands, or when receiving patch fragments when making changes on-device), make sure that you have enabled receiving SysEx messages with whatever midi driver you are using; rtmidi, for example, filters them out by default. (zero brought up this possibility when i was stumped.)\nyou need to turn on edit mode before doing much stuff, including before the pedal will send values back when edited on-device.\nfor our purposes, the most useful commands are those labeled FXM_OnOff and FXM_PN. the former enables/disables pedals and the latter changes pedals’ parameters. stripped of the SysEx header/footer, the latter message looks like this:\n52 00 64 31 ${pedalIndex} ${paramIndex} ${paramValueLow} ${paramValueHigh}\n\nhere, pedalIndex is the 0-indexed index of the pedal within the effects chain, paramIndex is the… 2(?)-indexed index of the parameter within the specific pedal, paramValueLow is the low 7 bits of the value, and paramValueHigh is the high 7 bits of the value. we found that the paramValue maps exactly onto the value shown on the device—there’s no hidden extra precision—so if a value is 0-100 on the device, you send 0-100.\nthe values/sliders/dials on the device’s display update in real-time when sending new parameter values, even for effects that normally can’t be edited on-device. it’s cute to see some of the little dials spin!"},"projects/mta-projection":{"title":"mta projection","links":[],"tags":[],"content":"link to project\nwhy is a map different from a diagram? i recently heard the MTA’s typical subway map described as a bit of a misnomer, because its lack of strict adherence to physical layout instead makes it a diagram.\n\nwhat if we stubbornly held that this is, in fact, a map? there are lots of different types of maps of the same underlying earth—not just displaying different information (streets, topography, buildings), but different projections as well. the subway map does display our earthly terrain, but under a rather unorthodox projection.\nhow might we better understand this projection? by viewing satellite imagery of the city under it. i built this project to do that—hit the button to see the mercator projection morph into the MTA projection."},"talks/mustard-watches":{"title":"mustard watches","links":[],"tags":[],"content":"\ni gave a short talk on y j ringard’s famous 1990 paper “mustard watches: an integrated approach to time and food” at cmu plunch on march 4, 2022. i covered both the material in the original paper and some of the developments that have happened since. the slides follow:\n"}}